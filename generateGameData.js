"use strict"
const fs = require("fs")
const prettier = require('prettier')

let pathCsvs = './rawData/csv/'
let filesName = [
  'ships',
  'modules',
  'red_star_sectors',
  'stars','artifacts',
  'spacebuildings',
  'yellow_star_sectors',
  'achievements',
  'alliance_levels',
  'cerb_groups',
  'planet_levels',
  'planets',
  'player_goals',
  'solar_system_gen_data',
]
// let filesName = ['modules']
let pathSave = './data/'

let ignoringHeaders = ['maxLevel','Name','TID','TID_Description','Icon','SlotType','Model']
let projectilesKeys = { // новые ключи для объединения 
  "Alpha": "AlphaRocket",
  "Delta": "DeltaRocket",
  "Omega": "OmegaRocket",
  "Dart": "DartLauncher",
  "EMPRocket": "EMPRocket",
  "HydroRocket":  "HydroRocket",
  "BomberRocket": "BomberLauncher",
}
let dronesList = ['ShipmentDrone','MiningDrone','AlphaDrone']
let cerberusList = ['CerberusSentinel', 'CerberusGuardian', 'CerberusInterceptor', 'CerberusColossus', 'CerberusDestroyer', 'CerberusBomber', 'CerberusPhoenix', 'CerberusStorm', 'CerberusGhosts']
let StarHeaders = ['EffectDurationx10','ActivationDelay','ActivationPrep','MaxDPSTime','APTPIOTTP','DisableTime']

generateFiles(pathCsvs,filesName,pathSave)

function generateFiles(pathCsvs,files,pathSave){
  for(let file of files){
    let json = CSVtoJSON(fs.readFileSync(`${pathCsvs}${file}.csv`,"utf8"))
    if(file == 'modules'){
      let projectiles = null
      let ships = null
      try {
        projectiles = CSVtoJSON(fs.readFileSync(`${pathCsvs}projectiles.csv`,"utf8"))
        ships = CSVtoJSON(fs.readFileSync(`${pathCsvs}ships.csv`,"utf8"))
      } catch (e) {
        console.log(e.name + ":" + `Файл "${pathCsvs}projectiles.csv" или "${pathCsvs}ships.csv" не найден, "modulesData.js" пропущен`)
        continue
      }
      projectiles = renameKeys(projectiles, projectilesKeys)
      let drones = {}
      for(let i of dronesList){
        drones[i] = ships[i]
      }
      json = combineObjects(json, drones);
      json = combineObjects(json, projectiles);
      json['Recoil']['ShowWSInfo'] = 1
      json['Immolation']['ShowWSInfo'] = 1
      json['EMPRocket']['ShowWSInfo'] = 1
      json = addStarInfo(json,'WS');
      json = addStarInfo(json,'BS');
      json['MiningBoost']['WhiteStarScore'].unshift(0) // ошибка в таблице, не хватает "0"
      json['MiningDrone']['MiningSpeed'] = [29.1, 33.3, 37.5, 41.7, 45.8, 52.2, 58.8, 65.2, 74.1, 85.7]; // хз как считать это
      
      json = fixOrder(json);
    }
    if(file == 'ships'){
      for(let cerb of cerberusList){
        json = fixModulesShipsData(json, cerb, 'InitialModule', 'InitialModuleLevels')
      }
      json = fixModulesShipsData(json, 'CorpFlagship', 'FlagshipModules', 'FlagshipModuleLevels')
    }
    if(file == 'yellow_star_sectors'){
      json = fixYSS(json)
    }
    file = `${pathSave}${file}Data.js`
    saveToFile(file,json)
  }
}

function saveToFile(file,jsonObj) {
  let varName = file.replace(/.*\/(.*)\.js/,'$1')
  let addData = addContent(varName)
  
  const content = `
// generated by ${__filename}
// at ${new Date().toDateString()}

let ${varName} = ${JSON.stringify(jsonObj, null, 2)}

${addData['content'] || ""}

 // module.exports = {${addData['export']}}
 export {${addData['export']}}
`
  fs.writeFileSync(
    file,
      prettier.format(content, {
          parser: 'babel',
          trailingComma: 'all',
          printWidth: 500, // чтоб массивы выстраивались в одну линию
      })
  )
console.log(`Файл ${file} создан`)
}

// парсер из таблицы в обектJS
function CSVtoJSON(csv){
  let data = csv.split('\n'); 
  let headers = data[0].split(',')
  let jsonObj = {}
  let name = null
  for(let i = 1; i <  data.length; i++){
    let string = data[i].split(',')
    if(string == "") continue
    if(string[0] !== ""){
      name = string[0]
      jsonObj[name] = {}
      jsonObj[name]['maxLevel'] = 1
    }else{
      jsonObj[name]['maxLevel']++
    }
    for(let j = 0; j < string.length; j++){
      let header = headers[j].trim()
      let value = string[j].trim()
      let stokValue = jsonObj[name][header]
      if(isTrashHeader(header) || value === undefined || value === "") continue
      value = fixValue(name, header, value)
      if(value == null) continue
      if(stokValue == undefined || stokValue === ""){
        jsonObj[name][header] = value
      }else{
        if(Array.isArray(stokValue)){
          jsonObj[name][header].push(value)
        }else{
          jsonObj[name][header] = []
          jsonObj[name][header].push(stokValue, value)
        }
      }
    }
  }
  return removeDupsFromArrays(jsonObj)
}

// скрыть/исправить значения для красоты результата
function fixValue(name, header, value){
  if(ignoringHeaders.includes(header)){
    return value
  }
  let fixValue = require(`${pathCsvs}modification/fixValue.js`).fixValue
  if(isHide(name, header)) return null
  for(let i in fixValue){
    if(fixValue[i]['header'].includes(header)){
        return fixValue[i]['func'](value)
    }
  }
  if(value >= 0){
    return parseInt(value)
  }
  return value
}
function isHide(name, header, strict = false){ // скрывает невалидные данные: "0", " " или просто ненужные,  strict - скрыть валидные данные (2я проверка)
let path = (strict) ? 'hide2' : 'hide'
  let hide = require(`${pathCsvs}modification/fixValue.js`)[path]
  for(let i in hide){
    if(hide[i]['name'].includes(name)){
        if(hide[i]['headers'].includes(header)){
          return true
        }
    }
  }
  return false
}
// массив, сравнивать i и i+1, если все элементы равны установить вместо массива i[0] || {key:[1,1,1,1]} => {key:1}
function removeDupsFromArrays(obj) {
  let names = Object.keys(obj)
  for(let name of names){
    let headlers = Object.keys(obj[name])
    for(let headler of headlers){
      let item = obj[name][headler]
      if(!(Array.isArray(item))) continue
      let isBreak = false
      for(let i = 0; i < item.length; i++){
          if(item[i] !== item[i+1] && item[i+1] !== undefined){
            isBreak = true
            break
          }
      }
      if(!(isBreak)){
        obj[name][headler] = item[0]
      }
    }
  }
  return obj
}

function combineObjects(obj1, obj2) {
  for (var p in obj2) {
    try {
      if(ignoringHeaders.includes(p)) continue
      if ( obj2[p].constructor == Object) {
        obj1[p] = combineObjects(obj1[p], obj2[p])
      } else {
        obj1[p] = obj2[p]
      }
    } catch(e) {
      obj1[p] = obj2[p]
    }
  }
  return obj1
}

function renameKeys(obj, newKeys) {
  const keyValues = Object.keys(obj).map(key => {
    const newKey = newKeys[key] || key
    return { [newKey]: obj[key] }
  })
  return Object.assign({}, ...keyValues)
}

// добавить захардкоженый контент
function addContent(type){
  let result = {}
  let content = null
  result['export'] = type
  switch(type) {
    case 'modulesData':
        let modulesByTypes = {
          trade: ['TransportCapacity', 'ShipmentComputer', 'Trader', 'Rush', 'TradeBurst', 'ShipmentDrone', 'Offload', 'ShipmentBeam', 'Entrust', 'Dispatch', 'Recall'],
          mining: ['MiningBoost', 'MineralStorageCapacity', 'Enrich', 'MassMining', 'HydrogenUpload', 'MiningUnity', 'Crunch', 'Genesis', 'HydroRocket', 'MiningDrone'],
          weapon: ['WeakBattery', 'Battery', 'Laser', 'MassBattery', 'DualLaser', 'Barrage', 'DartLauncher'],
          shield: ['WeakShield', 'StandardShield', 'PassiveShield', 'StrongShield', 'MirrorShield', 'BlastShield', 'AreaShield'],
          support: ['EMP', 'Teleport', 'RedStarExtender', 'Repair', 'TimeWarp', 'Unity', 'Sanctuary', 'Stealth', 'Fortify', 'Impulse', 'AlphaRocket', 'Salvage', 'Supress', 'Destiny', 'Barrier', 'Vengeance', 'DeltaRocket', 'Leap', 'Bond', 'AlphaDrone', 'Suspend', 'OmegaRocket'],
          cerberus: ['GuardianBattery','WeakBattery','InterceptorMBattery','ColossusLaser','DestroyerVengeance','BomberLauncher','PhoenixShield','DartBarrage'],
          flagship: ['Recoil','Immolation','EMPRocket']
        }
        result['content'] = 'let modulesByTypes= ' + JSON.stringify(modulesByTypes, null, 2)
        result['export'] += ',modulesByTypes'
      break;
    case 'shipsData':
      let shipsByTypes = {
        player: ['Transport', 'Miner', 'Battleship','CorpFlagship'],
        cerberus: cerberusList,
        drones: dronesList 
      }
      result['content'] = 'let shipsByTypes= ' + JSON.stringify(shipsByTypes, null, 2)
      result['export'] += ',shipsByTypes'
    break;
    default:
      break;
  }
  return result
}

// глобально скрытые значения - не имеют важности
function isTrashHeader(str) {
  let trashHeaders = JSON.parse(fs.readFileSync(`${pathCsvs}modification/trashHeaders.json`,"utf8").toLowerCase())
  str = str.toLowerCase()
  return (trashHeaders.includes(str) || str.startsWith('is') || str.includes('fx'))
}

// фикс модулей, добавление БЗ/ГЗ стат
function addStarInfo(obj,star){
  let coefficient = (v) => (star == 'WS') ? v*600 : v*2
  let isWhiteListBS = (header,name) => require(`${pathCsvs}modification/fixValue.js`).whiteListBS.checkList(header,name)
  let StarHeaders2 = []
  for(let i = 0; i < StarHeaders.length; i++){
    StarHeaders2[i] = StarHeaders[i] + star
  }
  for(let name in obj){
    let module = obj[name]
    let check = obj[name][`Show${star}Info`]
    delete obj[name][`Show${star}Info`]
    if(check != '1') continue
    for(let stata in module){
      if(StarHeaders.includes(stata)){
        if(star == 'BS'){ // пока тлоько для ГЗ
          if( !(isWhiteListBS(stata,name))) continue
        }
        if(!(Object.keys(module).includes(stata+star))){
          let stokStata = module[stata]
          if(!(Array.isArray(stokStata))) {
            obj[name][stata+star] = coefficient(stokStata)
            if(isHide(name, stata, true)){ // удалить оригинальную стату, если не нужна
              delete obj[name][stata]
            }
            continue
          }
          let arrayNoStar = stokStata
          let arrayStar = []
          for(let j in arrayNoStar){
            arrayStar.push(coefficient(arrayNoStar[j]))
          }
          obj[name][stata+star] = arrayStar
          if(isHide(name, stata, true)){ // удалить оригинальную стату, если не нужна
            delete obj[name][stata]
          }
        }
      }else{
        continue
      }
    }
  }
  return obj
}

// исправление порядка объекта
function fixOrder(obj){
  let headers = JSON.parse(fs.readFileSync(`${pathCsvs}modification/headersOrder.json`,"utf8"));
  let result = {}

  for(let i = 0; i < ObjectLength(obj); i++){
    let objCopy = Object.assign({}, obj); // сделать копию, чтобы не помять основной объект
    let path = null // уровень 0
    let key = Object.keys(objCopy)[i]
    //определение глубины 
    let depth = 0
    while(objCopy[key].constructor.name == 'Object'){
      path = (path == null) ? key : path + '.' + key
      key = Object.keys(objCopy[path])[depth]
      objCopy = objCopy[path]
      depth++
    }
    // создание объекта с ключами (+индекс)
    let objKeys = Object.keys(objCopy)
    let indexes = [];
    for(key in objCopy){
      let elem = {}
      let index = (headers.includes(key)) ? headers.indexOf(key) : 666
      elem['index'] = index
      elem['key'] = key
      indexes.push(elem)
    }
    // сортировка по идексу
    let objSorted = indexes.slice(0);
    objSorted.sort(function(a,b) {
      return a.index - b.index;
    });
    // сборка готового массива и объекта 
    let newKeys = []
    for(let k of objSorted){
      newKeys.push(k.key)
    }
    let result2 = {}
    for(key of newKeys){
      result2[key] = objCopy[key]
    }
    if(path != null){
      setToValue(result,result2,path)
    }else{
      result = result2
    }
  }
  return result   
}
function setToValue(obj, value, path) {
  var i;
  path = path.split('.');
  for (i = 0; i < path.length - 1; i++)
      obj = obj[path[i]];

  obj[path[i]] = value;
}
function ObjectLength(object) {
  let length = 0
  for(let key in object ) {
      if(object.hasOwnProperty(key)) {
          ++length
      }
  }
  return length
}
// из "{key:[module1!module2], key2:[1!2]}" в "{module1:[1], module2:[2]}"
function fixModulesShipsData(obj, name, Modules, ModuleLevels){
  let modules = (Array.isArray(obj[name][Modules])) ? obj[name][Modules] : [obj[name][Modules]]
  let levels = (Array.isArray(obj[name][ModuleLevels])) ? obj[name][ModuleLevels] : [obj[name][ModuleLevels]]
  let result = {}
  for(let i in modules){
    let moduleArr = modules[i].split('!')
    let levelArr = levels[i].split('!')
    for(let k in moduleArr){
      let key = moduleArr[k]
      let value = Number(levelArr[k]) + 1
      let stokValue = result[key]
      if(stokValue === undefined || stokValue === ""){
        result[key] = value
      }else{
        if(typeof(stokValue) == 'object'){
          result[key].push(value)
        }else{
          result[key] = []
          result[key].push(stokValue, value) 
        }
      }
    }
  }
  // изменить путь значений нового объекта для объединения результата с оригиналом
  // добавить недостающие нули, чтобы элементы массивов соответствовали уровню
  let result2 = {[name]:{}}
  for(let key in result){
    let needInts = obj[name]['maxLevel']
    for(let i = 0; i < needInts; i++){
      if(result[key].length < needInts){
        result[key].unshift(0)
      }else{
        result2[name][key] = result[key]
        continue
      }
    }
  }
  delete obj[name][Modules]
  delete obj[name][ModuleLevels]
  return combineObjects(obj,result2)
}

function fixYSS(obj){ // TODO
  let result = {}
  // for(let key in Object.keys(obj)){

  // }
  return obj
}