"use strict"
const fs = require("fs")
const prettier = require('prettier')

let pathCsvs = './rawData/csv/'
let filesName = [
  'ships',
  'modules',
  'red_star_sectors',
  'stars','artifacts',
  'spacebuildings',
  'yellow_star_sectors',
  'achievements',
  'alliance_levels',
  'cerb_groups',
  'planet_levels',
  'planets',
  'player_goals',
  'solar_system_gen_data',
]
// let filesName = ['yellow_star_sectors']
let pathSave = './data/'
let modulesPath = './generateGameData.js_modules/'

global.ignoringHeaders = ['maxLevel', 'Name', 'TID', 'TID_Description', 'Icon', 'SlotType', 'Model']
global.dronesList = ['ShipmentDrone', 'MiningDrone', 'AlphaDrone']
global.cerberusList = ['CerberusSentinel', 'CerberusGuardian', 'CerberusInterceptor', 'CerberusColossus', 'CerberusDestroyer', 'CerberusBomber', 'CerberusPhoenix', 'CerberusStorm', 'CerberusGhosts']

module.exports = {
  combineObjects,
  renameKeys,
  isHide
}

generateFiles(pathCsvs, filesName, pathSave)

function generateFiles(pathCsvs, files, pathSave) {
  let generateModules = require(`${modulesPath}modules.js`).generateModules
  let generateShips = require(`${modulesPath}ships.js`).generateShips
  let generateSolarSys = require(`${modulesPath}solarSystem.js`).generateSolarSys
  for (let file of files) {
    let json = CSVtoJSON(fs.readFileSync(`${pathCsvs}${file}.csv`, "utf8"))
    switch (file) {
      case 'modules':
        json = generateModules({
          rawData: json,
          shipsData: CSVtoJSON(fs.readFileSync(`${pathCsvs}ships.csv`, "utf8")),
          projectilesData: CSVtoJSON(fs.readFileSync(`${pathCsvs}projectiles.csv`, "utf8")),
          fixValue: require(`${pathCsvs}modification/fixValue.js`)
        })
        break;
      case 'ships':
        json = generateShips({
          rawData: json
        })
        break;
      case 'yellow_star_sectors':
        json = generateSolarSys({
          star: 'yellow',
          rawData: json,
          scannersData: CSVtoJSON(fs.readFileSync(`${pathCsvs}spacebuildings.csv`, "utf8")).ShortRangeScanner,
          cerberusData: CSVtoJSON(fs.readFileSync(`${pathCsvs}cerb_groups.csv`, "utf8")),
        })
        break;

      default:
        break;
    }
    file = `${pathSave}${file}Data.js`
    saveToFile(file, fixOrder(json))
  }
}

function saveToFile(file, jsonObj) {
  let addContent = require(`${modulesPath}addContent.js`).addContent
  let varName = file.replace(/.*\/(.*)\.js/, '$1')
  let addData = addContent(varName)

  const content = `
// generated by ${__filename}
// at ${new Date().toDateString()}

let ${varName} = ${JSON.stringify(jsonObj, null, 2)}

${addData['content'] || ""}

 // module.exports = {${addData['export']}}
 export {${addData['export']}}
`
  fs.writeFileSync(
    file,
    prettier.format(content, {
      parser: 'babel',
      trailingComma: 'es5',
      printWidth: 500, // чтоб массивы выстраивались в одну линию
    })
  )
  console.log(`Файл ${file} создан`)
}

// парсер из таблицы в обектJS
function CSVtoJSON(csv) {
  let data = csv.split('\n');
  let headers = data[0].split(',')
  let jsonObj = {}
  let name = null

  for (let i = 1; i < data.length; i++) {
    let string = data[i].split(',')

    if (string == "") continue
    if (string[0] !== "") {
      name = string[0]
      jsonObj[name] = {}
      jsonObj[name]['maxLevel'] = 1
    } else {
      jsonObj[name]['maxLevel']++
    }
    for (let j = 0; j < string.length; j++) {
      let header = headers[j].trim()
      let value = string[j].trim()
      let stokValue = jsonObj[name][header]

      if (isTrashHeader(header) || value === undefined || value === "") continue
      value = fixValue(name, header, value)
      if (value == null) continue
      if (stokValue == undefined || stokValue === "") {
        jsonObj[name][header] = value
      } else {
        if (Array.isArray(stokValue)) {
          jsonObj[name][header].push(value)
        } else {
          jsonObj[name][header] = []
          jsonObj[name][header].push(stokValue, value)
        }
      }
    }
  }
  return removeDupsFromArrays(jsonObj)
}

// скрыть/исправить значения для красоты результата
function fixValue(name, header, value) {
  if (ignoringHeaders.includes(header)) {
    return value
  }
  let fixValue = require(`${pathCsvs}modification/fixValue.js`).fixValue
  if (isHide(name, header)) return null
  for (let i in fixValue) {
    if (fixValue[i]['header'].includes(header)) {
      return fixValue[i]['func'](value)
    }
  }
  if (value >= 0) {
    return parseInt(value)
  }
  return value
}
function isHide(name, header, strict = false) { // скрывает невалидные данные: "0", " " или просто ненужные,  strict - скрыть валидные данные (2я проверка)
  let path = (strict) ? 'hide2' : 'hide'
  let hide = require(`${pathCsvs}modification/fixValue.js`)[path]
  for (let i in hide) {
    if (hide[i]['name'].includes(name)) {
      if (hide[i]['headers'].includes(header)) {
        return true
      }
    }
  }
  return false
}
// массив, сравнивать i и i+1, если все элементы равны установить вместо массива i[0] || {key:[1,1,1,1]} => {key:1}
function removeDupsFromArrays(obj) {
  let names = Object.keys(obj)
  for (let name of names) {
    let headlers = Object.keys(obj[name])
    for (let headler of headlers) {
      let item = obj[name][headler]
      if (!Array.isArray(item)) continue
      let isBreak = false
      for (let i = 0; i < item.length; i++) {
        if (item[i] !== item[i + 1] && item[i + 1] !== undefined) {
          isBreak = true // пока хз как лучше
          break
        }
      }
      if (!isBreak) {
        obj[name][headler] = item[0]
      }
    }
  }
  return obj
}

function combineObjects(obj1, obj2) {
  for (var p in obj2) {
    try {
      if (ignoringHeaders.includes(p)) continue
      if (obj2[p].constructor == Object) {
        obj1[p] = combineObjects(obj1[p], obj2[p])
      } else {
        obj1[p] = obj2[p]
      }
    } catch (e) {
      obj1[p] = obj2[p]
    }
  }
  return obj1
}

function renameKeys(obj, newKeys) {
  const keyValues = Object.keys(obj).map(key => {
    const newKey = newKeys[key] || key
    return { [newKey]: obj[key] }
  })
  return Object.assign({}, ...keyValues)
}

// глобально скрытые значения - не имеют важности
function isTrashHeader(str) {
  let trashHeaders = JSON.parse(fs.readFileSync(`${pathCsvs}modification/trashHeaders.json`, "utf8").toLowerCase())
  str = str.toLowerCase()
  return (trashHeaders.includes(str) || str.startsWith('is') || str.includes('fx'))
}

// исправление порядка объекта
function fixOrder(obj) {
  let headers = JSON.parse(fs.readFileSync(`${pathCsvs}modification/headersOrder.json`, "utf8"));
  let result = {}

  for (let i = 0; i < ObjectLength(obj); i++) {
    let objCopy = Object.assign({}, obj); // сделать копию, чтобы не помять основной объект
    let path = null // уровень 0
    let key = Object.keys(objCopy)[i]
    //определение глубины 
    let depth = 0
    while (objCopy[key].constructor.name == 'Object') {
      path = (path == null) ? key : path + '.' + key
      key = Object.keys(objCopy[path])[depth]
      objCopy = objCopy[path]
      depth++
    }
    // создание объекта с ключами (+индекс)
    let objKeys = Object.keys(objCopy)
    let indexes = [];
    for (key in objCopy) {
      let elem = {}
      let index = (headers.includes(key)) ? headers.indexOf(key) : 666
      elem['index'] = index
      elem['key'] = key
      indexes.push(elem)
    }
    // сортировка по идексу
    let objSorted = indexes.slice(0);
    objSorted.sort(function (a, b) {
      return a.index - b.index;
    });
    // сборка готового массива и объекта 
    let newKeys = []
    for (let k of objSorted) {
      newKeys.push(k.key)
    }
    let result2 = {}
    for (key of newKeys) {
      result2[key] = objCopy[key]
    }
    if (path != null) {
      setToValue(result, result2, path)
    } else {
      result = result2
    }
  }
  return result
}
function setToValue(obj, value, path) {
  var i;
  path = path.split('.');
  for (i = 0; i < path.length - 1; i++)
    obj = obj[path[i]];

  obj[path[i]] = value;
}
function ObjectLength(object) {
  let length = 0
  for (let key in object) {
    if (object.hasOwnProperty(key)) {
      ++length
    }
  }
  return length
}